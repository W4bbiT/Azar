{"ast":null,"code":"import _asyncToGenerator from \"/Users/Azar/Desktop/KC/myshop/KC-Frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport VanillaFlicking__default, { EVENTS, withFlickingMethods, ExternalRenderer, getFlickingAttached, getDefaultCameraTransform, VirtualRenderingStrategy, NormalRenderingStrategy, sync, range, CLASS } from '@egjs/flicking';\nexport * from '@egjs/flicking';\nimport * as i0 from '@angular/core';\nimport { Directive, EventEmitter, PLATFORM_ID, Component, ViewEncapsulation, Inject, Input, Output, HostBinding, ContentChildren, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { Subject, fromEvent } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport ListDiffer from '@egjs/list-differ';\nimport { __decorate } from 'tslib';\n\n/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nconst _c0 = [\"*\", [[\"\", \"in-viewport\", \"\"]]];\nconst _c1 = [\"*\", \"[in-viewport]\"];\nlet NgxFlickingPanel = /*#__PURE__*/(() => {\n  class NgxFlickingPanel {\n    get nativeElement() {\n      return this._host.nativeElement;\n    }\n    get rendered() {\n      return this._rendered;\n    }\n    constructor(_host, _renderer) {\n      this._host = _host;\n      this._renderer = _renderer;\n      this._rendered = true;\n    }\n    show(flicking) {\n      this._rendered = true;\n      const el = this.nativeElement;\n      const cameraEl = flicking.camera.element;\n      if (el.parentElement !== cameraEl) {\n        this._renderer.appendChild(cameraEl, el);\n      }\n    }\n    hide(flicking) {\n      this._rendered = false;\n      const el = this.nativeElement;\n      const cameraEl = flicking.camera.element;\n      if (el.parentElement === cameraEl) {\n        this._renderer.removeChild(cameraEl, el);\n      }\n    }\n  }\n  NgxFlickingPanel.ɵfac = function NgxFlickingPanel_Factory(t) {\n    return new (t || NgxFlickingPanel)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n  NgxFlickingPanel.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxFlickingPanel,\n    selectors: [[\"\", \"flicking-panel\", \"\"], [\"\", \"FlickingPanel\", \"\"]],\n    standalone: true\n  });\n  return NgxFlickingPanel;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst EVENT_NAMES = Object.keys(EVENTS).map(key => EVENTS[key]);\nlet FlickingInterface = /*#__PURE__*/(() => {\n  class FlickingInterface {}\n  __decorate([withFlickingMethods], FlickingInterface.prototype, \"_vanillaFlicking\", void 0);\n  return FlickingInterface;\n})();\nclass NgxRenderer extends ExternalRenderer {\n  constructor(options) {\n    super(options);\n    this._ngxFlicking = options.ngxFlicking;\n    this._ngxRenderer = options.ngxRenderer;\n  }\n  // eslint-disable-next-line @typescript-eslint/require-await\n  render() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const flicking = getFlickingAttached(_this._flicking);\n      const strategy = _this._strategy;\n      strategy.updateRenderingPanels(flicking);\n      strategy.renderPanels(flicking);\n      _this._resetPanelElementOrder();\n      _this._afterRender();\n    })();\n  }\n  _collectPanels() {\n    const flicking = getFlickingAttached(this._flicking);\n    const children = this._ngxFlicking.ngxPanels.toArray();\n    this._panels = this._strategy.collectPanels(flicking, children);\n  }\n  _createPanel(externalComponent, options) {\n    return this._strategy.createPanel(externalComponent, options);\n  }\n  _resetPanelElementOrder() {\n    const flicking = getFlickingAttached(this._flicking);\n    const renderer = this._ngxRenderer;\n    const cameraEl = flicking.camera.element;\n    // We're using reversed panels here as last panel should be the last element of camera element\n    const reversedElements = this._strategy.getRenderingElementsByOrder(flicking).reverse();\n    reversedElements.forEach((el, idx) => {\n      const nextEl = reversedElements[idx - 1] ? reversedElements[idx - 1] : null;\n      if (el.nextElementSibling !== nextEl) {\n        renderer.insertBefore(cameraEl, el, nextEl);\n      }\n    });\n  }\n}\nclass NgxElementProvider {\n  get element() {\n    return this._el.nativeElement;\n  }\n  get rendered() {\n    return this._el.rendered;\n  }\n  constructor(el) {\n    this._el = el;\n  }\n  show(flicking) {\n    this._el.show(flicking);\n  }\n  hide(flicking) {\n    this._el.hide(flicking);\n  }\n}\n\n/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nlet NgxFlickingComponent = /*#__PURE__*/(() => {\n  class NgxFlickingComponent extends FlickingInterface {\n    get isVertical() {\n      return this.options.horizontal === false;\n    }\n    get isHiddenBeforeInit() {\n      const initialized = this._vanillaFlicking && this._vanillaFlicking.initialized;\n      return this.hideBeforeInit && !initialized;\n    }\n    get cameraStyleBeforeInit() {\n      const initialized = this._vanillaFlicking && this._vanillaFlicking.initialized;\n      return !initialized && this.firstPanelSize ? {\n        transform: getDefaultCameraTransform(this.options.align, this.options.horizontal, this.firstPanelSize)\n      } : {};\n    }\n    get ngxPanels() {\n      return this._ngxPanels;\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    get _cameraElClass() {\n      return `flicking-camera ${this.cameraClass ?? \"\"}`.trim();\n    }\n    constructor(_elRef, _ngxRenderer, _platformId, _ngZone) {\n      super();\n      this._elRef = _elRef;\n      this._ngxRenderer = _ngxRenderer;\n      this._platformId = _platformId;\n      this._ngZone = _ngZone;\n      this.options = {};\n      this.plugins = [];\n      this.hideBeforeInit = false;\n      this._pluginsDiffer = new ListDiffer();\n      this._destroy$ = new Subject();\n      this._vanillaFlicking = null;\n      EVENT_NAMES.forEach(evtName => {\n        this[evtName] = new EventEmitter();\n      });\n    }\n    ngAfterViewInit() {\n      if (!isPlatformBrowser(this._platformId)) return;\n      const options = this.options;\n      const viewportEl = this._elRef.nativeElement;\n      const virtual = options.virtual && options.panelsPerView > 0;\n      const rendererOptions = {\n        ngxFlicking: this,\n        align: options.align,\n        ngxRenderer: this._ngxRenderer,\n        strategy: virtual ? new VirtualRenderingStrategy() : new NormalRenderingStrategy({\n          providerCtor: NgxElementProvider\n        })\n      };\n      if (virtual) {\n        this._initVirtualElements();\n      }\n      // Initialize `VanillaFlicking` outside of the Angular zone so it will set up `mousedown`\n      // and `mousemove` event listeners within the root zone, and it won't trigger change detection\n      // every time the user moves the mouse.\n      const flicking = this._ngZone.runOutsideAngular(() => new VanillaFlicking__default(viewportEl, {\n        ...this.options,\n        externalRenderer: new NgxRenderer(rendererOptions)\n      }));\n      this._vanillaFlicking = flicking;\n      const elementDiffer = new ListDiffer(this._ngxPanels.toArray());\n      this._bindEvents();\n      this._checkPlugins();\n      if (this.status) {\n        flicking.setStatus(this.status);\n      }\n      // Note: doesn't need to unsubscribe, because `changes`\n      // gets completed by Angular when the view is destroyed.\n      this._ngxPanels.changes.subscribe(() => {\n        const panels = this._ngxPanels.toArray();\n        const diffResult = elementDiffer.update(panels);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        sync(flicking, diffResult, [...diffResult.maintained.map(([_, idx]) => diffResult.list[idx]), ...diffResult.added.map(idx => diffResult.list[idx])]);\n      });\n    }\n    ngOnDestroy() {\n      this._destroy$.next();\n      this._vanillaFlicking?.destroy();\n    }\n    ngOnChanges() {\n      const flicking = this._vanillaFlicking;\n      if (!flicking) return;\n      this._ngZone.runOutsideAngular(() => {\n        void flicking.renderer.forceRenderAllPanels();\n      });\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const {\n        virtual,\n        ...newOptions\n      } = this.options;\n      // Omit 'virtual', as it can't have any setter\n      for (const key in newOptions) {\n        if (key in flicking && flicking[key] !== newOptions[key]) {\n          flicking[key] = newOptions[key];\n        }\n      }\n      this._checkPlugins();\n    }\n    _bindEvents() {\n      const flicking = this._vanillaFlicking;\n      EVENT_NAMES.forEach(evtName => {\n        // `fromEvent` supports passing `JQueryStyleEventEmitter`\n        // (an object with `on` and `off` methods). `flicking` acts as a\n        // jQuery event emitter since it has both methods.\n        fromEvent(flicking, evtName).pipe(takeUntil(this._destroy$)).subscribe(e => {\n          // Style guide: Event - https://angular.io/guide/styleguide#dont-prefix-output-properties\n          const emitter = this[evtName];\n          e.currentTarget = this;\n          if (emitter && emitter.observers.length > 0) {\n            this._ngZone.run(() => emitter.emit(e));\n          }\n        });\n      });\n    }\n    _checkPlugins() {\n      const flicking = this._vanillaFlicking;\n      if (!flicking) return;\n      const {\n        list,\n        added,\n        removed,\n        prevList\n      } = this._pluginsDiffer.update(this.plugins);\n      flicking.addPlugins(...added.map(index => list[index]));\n      flicking.removePlugins(...removed.map(index => prevList[index]));\n    }\n    _initVirtualElements() {\n      const options = this.options;\n      const renderer = this._ngxRenderer;\n      const cameraElement = this._elRef.nativeElement.firstElementChild;\n      const panelsPerView = options.panelsPerView;\n      const virtual = options.virtual;\n      const fragment = document.createDocumentFragment();\n      const newElements = range(panelsPerView + 1).map(idx => {\n        const panelEl = renderer.createElement(\"div\");\n        panelEl.className = virtual.panelClass ?? CLASS.DEFAULT_VIRTUAL;\n        panelEl.dataset.elementIndex = idx.toString();\n        return panelEl;\n      });\n      newElements.forEach(el => {\n        fragment.appendChild(el);\n      });\n      renderer.appendChild(cameraElement, fragment);\n    }\n  }\n  NgxFlickingComponent.ɵfac = function NgxFlickingComponent_Factory(t) {\n    return new (t || NgxFlickingComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(PLATFORM_ID), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  NgxFlickingComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxFlickingComponent,\n    selectors: [[\"ngx-flicking\"], [\"\", \"NgxFlicking\", \"\"]],\n    contentQueries: function NgxFlickingComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NgxFlickingPanel, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._ngxPanels = _t);\n      }\n    },\n    hostAttrs: [1, \"flicking-viewport\", 2, \"display\", \"block\"],\n    hostVars: 4,\n    hostBindings: function NgxFlickingComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"vertical\", ctx.isVertical)(\"flicking-hidden\", ctx.isHiddenBeforeInit);\n      }\n    },\n    inputs: {\n      options: \"options\",\n      plugins: \"plugins\",\n      status: \"status\",\n      cameraClass: \"cameraClass\",\n      hideBeforeInit: \"hideBeforeInit\",\n      firstPanelSize: \"firstPanelSize\"\n    },\n    outputs: {\n      ready: \"ready\",\n      beforeResize: \"beforeResize\",\n      afterResize: \"afterResize\",\n      holdStart: \"holdStart\",\n      holdEnd: \"holdEnd\",\n      moveStart: \"moveStart\",\n      move: \"move\",\n      moveEnd: \"moveEnd\",\n      willChange: \"willChange\",\n      changed: \"changed\",\n      willRestore: \"willRestore\",\n      restored: \"restored\",\n      select: \"select\",\n      needPanel: \"needPanel\",\n      visibleChange: \"visibleChange\",\n      reachEdge: \"reachEdge\",\n      panelChange: \"panelChange\"\n    },\n    standalone: true,\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 2,\n    consts: [[3, \"ngClass\", \"ngStyle\"]],\n    template: function NgxFlickingComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c0);\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(2, 1);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", ctx._cameraElClass)(\"ngStyle\", ctx.cameraStyleBeforeInit);\n      }\n    },\n    dependencies: [CommonModule, i1.NgClass, i1.NgStyle],\n    styles: [\".flicking-viewport{position:relative;overflow:hidden}.flicking-viewport.vertical{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex}.flicking-viewport.vertical>.flicking-camera{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.flicking-viewport.flicking-hidden>.flicking-camera>*{visibility:hidden}.flicking-camera{width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;position:relative;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;z-index:1;will-change:transform}.flicking-camera>*{-ms-flex-negative:0;flex-shrink:0}\\n\"],\n    encapsulation: 2\n  });\n  return NgxFlickingComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxFlickingModule = /*#__PURE__*/(() => {\n  class NgxFlickingModule {}\n  NgxFlickingModule.ɵfac = function NgxFlickingModule_Factory(t) {\n    return new (t || NgxFlickingModule)();\n  };\n  NgxFlickingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxFlickingModule\n  });\n  NgxFlickingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [NgxFlickingComponent]\n  });\n  return NgxFlickingModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of ngx-flicking\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxFlickingComponent, NgxFlickingModule, NgxFlickingPanel };\n//# sourceMappingURL=egjs-ngx-flicking.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}