import VanillaFlicking__default, { EVENTS, withFlickingMethods, ExternalRenderer, getFlickingAttached, getDefaultCameraTransform, VirtualRenderingStrategy, NormalRenderingStrategy, sync, range, CLASS } from '@egjs/flicking';
export * from '@egjs/flicking';
import * as i0 from '@angular/core';
import { Directive, EventEmitter, PLATFORM_ID, Component, ViewEncapsulation, Inject, Input, Output, HostBinding, ContentChildren, NgModule } from '@angular/core';
import { __decorate, __awaiter, __rest } from 'tslib';
import * as i1 from '@angular/common';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import { Subject, fromEvent } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import ListDiffer from '@egjs/list-differ';

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
class NgxFlickingPanel {
    get nativeElement() {
        return this._host.nativeElement;
    }
    get rendered() {
        return this._rendered;
    }
    constructor(_host, _renderer) {
        this._host = _host;
        this._renderer = _renderer;
        this._rendered = true;
    }
    show(flicking) {
        this._rendered = true;
        const el = this.nativeElement;
        const cameraEl = flicking.camera.element;
        if (el.parentElement !== cameraEl) {
            this._renderer.appendChild(cameraEl, el);
        }
    }
    hide(flicking) {
        this._rendered = false;
        const el = this.nativeElement;
        const cameraEl = flicking.camera.element;
        if (el.parentElement === cameraEl) {
            this._renderer.removeChild(cameraEl, el);
        }
    }
}
NgxFlickingPanel.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: NgxFlickingPanel, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
NgxFlickingPanel.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.2", type: NgxFlickingPanel, isStandalone: true, selector: "[flicking-panel], [FlickingPanel]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: NgxFlickingPanel, decorators: [{
            type: Directive,
            args: [{
                    selector: '[flicking-panel], [FlickingPanel]',
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }]; } });

const EVENT_NAMES = Object.keys(EVENTS).map((key) => EVENTS[key]);

class FlickingInterface {
}
__decorate([
    withFlickingMethods
], FlickingInterface.prototype, "_vanillaFlicking", void 0);

class NgxRenderer extends ExternalRenderer {
    constructor(options) {
        super(options);
        this._ngxFlicking = options.ngxFlicking;
        this._ngxRenderer = options.ngxRenderer;
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    render() {
        return __awaiter(this, void 0, void 0, function* () {
            const flicking = getFlickingAttached(this._flicking);
            const strategy = this._strategy;
            strategy.updateRenderingPanels(flicking);
            strategy.renderPanels(flicking);
            this._resetPanelElementOrder();
            this._afterRender();
        });
    }
    _collectPanels() {
        const flicking = getFlickingAttached(this._flicking);
        const children = this._ngxFlicking.ngxPanels.toArray();
        this._panels = this._strategy.collectPanels(flicking, children);
    }
    _createPanel(externalComponent, options) {
        return this._strategy.createPanel(externalComponent, options);
    }
    _resetPanelElementOrder() {
        const flicking = getFlickingAttached(this._flicking);
        const renderer = this._ngxRenderer;
        const cameraEl = flicking.camera.element;
        // We're using reversed panels here as last panel should be the last element of camera element
        const reversedElements = this._strategy
            .getRenderingElementsByOrder(flicking)
            .reverse();
        reversedElements.forEach((el, idx) => {
            const nextEl = reversedElements[idx - 1] ? reversedElements[idx - 1] : null;
            if (el.nextElementSibling !== nextEl) {
                renderer.insertBefore(cameraEl, el, nextEl);
            }
        });
    }
}

class NgxElementProvider {
    get element() { return this._el.nativeElement; }
    get rendered() { return this._el.rendered; }
    constructor(el) {
        this._el = el;
    }
    show(flicking) {
        this._el.show(flicking);
    }
    hide(flicking) {
        this._el.hide(flicking);
    }
}

class NgxFlickingComponent extends FlickingInterface {
    get isVertical() {
        return this.options.horizontal === false;
    }
    get isHiddenBeforeInit() {
        const initialized = this._vanillaFlicking && this._vanillaFlicking.initialized;
        return this.hideBeforeInit && !initialized;
    }
    get cameraStyleBeforeInit() {
        const initialized = this._vanillaFlicking && this._vanillaFlicking.initialized;
        return !initialized && this.firstPanelSize
            ? { transform: getDefaultCameraTransform(this.options.align, this.options.horizontal, this.firstPanelSize) }
            : {};
    }
    get ngxPanels() { return this._ngxPanels; }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    get _cameraElClass() { var _a; return `flicking-camera ${(_a = this.cameraClass) !== null && _a !== void 0 ? _a : ""}`.trim(); }
    constructor(_elRef, _ngxRenderer, _platformId, _ngZone) {
        super();
        this._elRef = _elRef;
        this._ngxRenderer = _ngxRenderer;
        this._platformId = _platformId;
        this._ngZone = _ngZone;
        this.options = {};
        this.plugins = [];
        this.hideBeforeInit = false;
        this._pluginsDiffer = new ListDiffer();
        this._destroy$ = new Subject();
        this._vanillaFlicking = null;
        EVENT_NAMES.forEach(evtName => {
            this[evtName] = new EventEmitter();
        });
    }
    ngAfterViewInit() {
        if (!isPlatformBrowser(this._platformId))
            return;
        const options = this.options;
        const viewportEl = this._elRef.nativeElement;
        const virtual = options.virtual && options.panelsPerView > 0;
        const rendererOptions = {
            ngxFlicking: this,
            align: options.align,
            ngxRenderer: this._ngxRenderer,
            strategy: virtual
                ? new VirtualRenderingStrategy()
                : new NormalRenderingStrategy({
                    providerCtor: NgxElementProvider
                })
        };
        if (virtual) {
            this._initVirtualElements();
        }
        // Initialize `VanillaFlicking` outside of the Angular zone so it will set up `mousedown`
        // and `mousemove` event listeners within the root zone, and it won't trigger change detection
        // every time the user moves the mouse.
        const flicking = this._ngZone.runOutsideAngular(() => new VanillaFlicking__default(viewportEl, Object.assign(Object.assign({}, this.options), { externalRenderer: new NgxRenderer(rendererOptions) })));
        this._vanillaFlicking = flicking;
        const elementDiffer = new ListDiffer(this._ngxPanels.toArray());
        this._bindEvents();
        this._checkPlugins();
        if (this.status) {
            flicking.setStatus(this.status);
        }
        // Note: doesn't need to unsubscribe, because `changes`
        // gets completed by Angular when the view is destroyed.
        this._ngxPanels.changes.subscribe(() => {
            const panels = this._ngxPanels.toArray();
            const diffResult = elementDiffer.update(panels);
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            sync(flicking, diffResult, [...diffResult.maintained.map(([_, idx]) => diffResult.list[idx]), ...diffResult.added.map(idx => diffResult.list[idx])]);
        });
    }
    ngOnDestroy() {
        var _a;
        this._destroy$.next();
        (_a = this._vanillaFlicking) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    ngOnChanges() {
        const flicking = this._vanillaFlicking;
        if (!flicking)
            return;
        this._ngZone.runOutsideAngular(() => {
            void flicking.renderer.forceRenderAllPanels();
        });
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const _a = this.options, { virtual } = _a, newOptions = __rest(_a, ["virtual"]);
        // Omit 'virtual', as it can't have any setter
        for (const key in newOptions) {
            if (key in flicking && flicking[key] !== newOptions[key]) {
                flicking[key] = newOptions[key];
            }
        }
        this._checkPlugins();
    }
    _bindEvents() {
        const flicking = this._vanillaFlicking;
        EVENT_NAMES.forEach(evtName => {
            // `fromEvent` supports passing `JQueryStyleEventEmitter`
            // (an object with `on` and `off` methods). `flicking` acts as a
            // jQuery event emitter since it has both methods.
            fromEvent(flicking, evtName)
                .pipe(takeUntil(this._destroy$))
                .subscribe((e) => {
                // Style guide: Event - https://angular.io/guide/styleguide#dont-prefix-output-properties
                const emitter = this[evtName];
                e.currentTarget = this;
                if (emitter && emitter.observers.length > 0) {
                    this._ngZone.run(() => emitter.emit(e));
                }
            });
        });
    }
    _checkPlugins() {
        const flicking = this._vanillaFlicking;
        if (!flicking)
            return;
        const { list, added, removed, prevList } = this._pluginsDiffer.update(this.plugins);
        flicking.addPlugins(...added.map(index => list[index]));
        flicking.removePlugins(...removed.map(index => prevList[index]));
    }
    _initVirtualElements() {
        const options = this.options;
        const renderer = this._ngxRenderer;
        const cameraElement = this._elRef.nativeElement.firstElementChild;
        const panelsPerView = options.panelsPerView;
        const virtual = options.virtual;
        const fragment = document.createDocumentFragment();
        const newElements = range(panelsPerView + 1).map(idx => {
            var _a;
            const panelEl = renderer.createElement("div");
            panelEl.className = (_a = virtual.panelClass) !== null && _a !== void 0 ? _a : CLASS.DEFAULT_VIRTUAL;
            panelEl.dataset.elementIndex = idx.toString();
            return panelEl;
        });
        newElements.forEach(el => {
            fragment.appendChild(el);
        });
        renderer.appendChild(cameraElement, fragment);
    }
}
NgxFlickingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: NgxFlickingComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: PLATFORM_ID }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
NgxFlickingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.2", type: NgxFlickingComponent, isStandalone: true, selector: "ngx-flicking, [NgxFlicking]", inputs: { options: "options", plugins: "plugins", status: "status", cameraClass: "cameraClass", hideBeforeInit: "hideBeforeInit", firstPanelSize: "firstPanelSize" }, outputs: { ready: "ready", beforeResize: "beforeResize", afterResize: "afterResize", holdStart: "holdStart", holdEnd: "holdEnd", moveStart: "moveStart", move: "move", moveEnd: "moveEnd", willChange: "willChange", changed: "changed", willRestore: "willRestore", restored: "restored", select: "select", needPanel: "needPanel", visibleChange: "visibleChange", reachEdge: "reachEdge", panelChange: "panelChange" }, host: { properties: { "class.vertical": "this.isVertical", "class.flicking-hidden": "this.isHiddenBeforeInit" }, styleAttribute: "display: block;", classAttribute: "flicking-viewport" }, queries: [{ propertyName: "_ngxPanels", predicate: NgxFlickingPanel }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: `
    <div [ngClass]="_cameraElClass" [ngStyle]="cameraStyleBeforeInit">
      <ng-content></ng-content>
    </div>
    <ng-content select="[in-viewport]"></ng-content>`, isInline: true, styles: [".flicking-viewport{position:relative;overflow:hidden}.flicking-viewport.vertical{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex}.flicking-viewport.vertical>.flicking-camera{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.flicking-viewport.flicking-hidden>.flicking-camera>*{visibility:hidden}.flicking-camera{width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;position:relative;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;z-index:1;will-change:transform}.flicking-camera>*{-ms-flex-negative:0;flex-shrink:0}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }], encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: NgxFlickingComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-flicking, [NgxFlicking]', template: `
    <div [ngClass]="_cameraElClass" [ngStyle]="cameraStyleBeforeInit">
      <ng-content></ng-content>
    </div>
    <ng-content select="[in-viewport]"></ng-content>`, host: {
                        class: 'flicking-viewport',
                        style: 'display: block;',
                    }, encapsulation: ViewEncapsulation.None, standalone: true, imports: [CommonModule], styles: [".flicking-viewport{position:relative;overflow:hidden}.flicking-viewport.vertical{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex}.flicking-viewport.vertical>.flicking-camera{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.flicking-viewport.flicking-hidden>.flicking-camera>*{visibility:hidden}.flicking-camera{width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;position:relative;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;z-index:1;will-change:transform}.flicking-camera>*{-ms-flex-negative:0;flex-shrink:0}\n"] }]
        }], ctorParameters: function () {
        return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [PLATFORM_ID]
                    }] }, { type: i0.NgZone }];
    }, propDecorators: { options: [{
                type: Input
            }], plugins: [{
                type: Input
            }], status: [{
                type: Input
            }], cameraClass: [{
                type: Input
            }], hideBeforeInit: [{
                type: Input
            }], firstPanelSize: [{
                type: Input
            }], ready: [{
                type: Output
            }], beforeResize: [{
                type: Output
            }], afterResize: [{
                type: Output
            }], holdStart: [{
                type: Output
            }], holdEnd: [{
                type: Output
            }], moveStart: [{
                type: Output
            }], move: [{
                type: Output
            }], moveEnd: [{
                type: Output
            }], willChange: [{
                type: Output
            }], changed: [{
                type: Output
            }], willRestore: [{
                type: Output
            }], restored: [{
                type: Output
            }], select: [{
                type: Output
            }], needPanel: [{
                type: Output
            }], visibleChange: [{
                type: Output
            }], reachEdge: [{
                type: Output
            }], panelChange: [{
                type: Output
            }], isVertical: [{
                type: HostBinding,
                args: ["class.vertical"]
            }], isHiddenBeforeInit: [{
                type: HostBinding,
                args: ["class.flicking-hidden"]
            }], _ngxPanels: [{
                type: ContentChildren,
                args: [NgxFlickingPanel]
            }] } });

class NgxFlickingModule {
}
NgxFlickingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: NgxFlickingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgxFlickingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.2", ngImport: i0, type: NgxFlickingModule, imports: [NgxFlickingComponent, NgxFlickingPanel], exports: [NgxFlickingComponent, NgxFlickingPanel] });
NgxFlickingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: NgxFlickingModule, imports: [NgxFlickingComponent] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: NgxFlickingModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [NgxFlickingComponent, NgxFlickingPanel],
                    exports: [NgxFlickingComponent, NgxFlickingPanel],
                }]
        }] });

/*
 * Public API Surface of ngx-flicking
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxFlickingComponent, NgxFlickingModule, NgxFlickingPanel };
//# sourceMappingURL=egjs-ngx-flicking.mjs.map
