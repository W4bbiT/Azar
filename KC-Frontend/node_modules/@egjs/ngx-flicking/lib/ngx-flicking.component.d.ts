/**
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
import { AfterViewInit, ElementRef, OnChanges, EventEmitter, OnDestroy, QueryList, Renderer2, NgZone } from '@angular/core';
import { FlickingOptions, Plugin, Status, SelectEvent, NeedPanelEvent, VisibleChangeEvent, HoldStartEvent, HoldEndEvent, MoveStartEvent, MoveEvent, MoveEndEvent, WillChangeEvent, ChangedEvent, WillRestoreEvent, RestoredEvent, ReadyEvent, BeforeResizeEvent, AfterResizeEvent, ReachEdgeEvent, PanelChangeEvent } from '@egjs/flicking';
import FlickingInterface from './FlickingInterface';
import { NgxFlickingPanel } from './ngx-flicking-panel.directive';
import * as i0 from "@angular/core";
export declare class NgxFlickingComponent extends FlickingInterface implements AfterViewInit, OnDestroy, OnChanges {
    private _elRef;
    private _ngxRenderer;
    private _platformId;
    private _ngZone;
    options: Partial<FlickingOptions>;
    plugins: Plugin[];
    status: Status;
    cameraClass: string;
    hideBeforeInit: boolean;
    firstPanelSize: string;
    ready: EventEmitter<ReadyEvent<NgxFlickingComponent>>;
    beforeResize: EventEmitter<BeforeResizeEvent<NgxFlickingComponent>>;
    afterResize: EventEmitter<AfterResizeEvent<NgxFlickingComponent>>;
    holdStart: EventEmitter<HoldStartEvent<NgxFlickingComponent>>;
    holdEnd: EventEmitter<HoldEndEvent<NgxFlickingComponent>>;
    moveStart: EventEmitter<MoveStartEvent<NgxFlickingComponent>>;
    move: EventEmitter<MoveEvent<NgxFlickingComponent>>;
    moveEnd: EventEmitter<MoveEndEvent<NgxFlickingComponent>>;
    willChange: EventEmitter<WillChangeEvent<NgxFlickingComponent>>;
    changed: EventEmitter<ChangedEvent<NgxFlickingComponent>>;
    willRestore: EventEmitter<WillRestoreEvent<NgxFlickingComponent>>;
    restored: EventEmitter<RestoredEvent<NgxFlickingComponent>>;
    select: EventEmitter<SelectEvent<NgxFlickingComponent>>;
    needPanel: EventEmitter<NeedPanelEvent<NgxFlickingComponent>>;
    visibleChange: EventEmitter<VisibleChangeEvent<NgxFlickingComponent>>;
    reachEdge: EventEmitter<ReachEdgeEvent<NgxFlickingComponent>>;
    panelChange: EventEmitter<PanelChangeEvent<NgxFlickingComponent>>;
    get isVertical(): boolean;
    get isHiddenBeforeInit(): boolean;
    get cameraStyleBeforeInit(): {
        transform: string;
    } | {
        transform?: undefined;
    };
    private _ngxPanels;
    private _pluginsDiffer;
    get ngxPanels(): QueryList<NgxFlickingPanel>;
    get _cameraElClass(): string;
    private _destroy$;
    constructor(_elRef: ElementRef<HTMLElement>, _ngxRenderer: Renderer2, _platformId: string, _ngZone: NgZone);
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    ngOnChanges(): void;
    private _bindEvents;
    private _checkPlugins;
    private _initVirtualElements;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxFlickingComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NgxFlickingComponent, "ngx-flicking, [NgxFlicking]", never, { "options": "options"; "plugins": "plugins"; "status": "status"; "cameraClass": "cameraClass"; "hideBeforeInit": "hideBeforeInit"; "firstPanelSize": "firstPanelSize"; }, { "ready": "ready"; "beforeResize": "beforeResize"; "afterResize": "afterResize"; "holdStart": "holdStart"; "holdEnd": "holdEnd"; "moveStart": "moveStart"; "move": "move"; "moveEnd": "moveEnd"; "willChange": "willChange"; "changed": "changed"; "willRestore": "willRestore"; "restored": "restored"; "select": "select"; "needPanel": "needPanel"; "visibleChange": "visibleChange"; "reachEdge": "reachEdge"; "panelChange": "panelChange"; }, ["_ngxPanels"], ["*", "[in-viewport]"], true, never>;
}
